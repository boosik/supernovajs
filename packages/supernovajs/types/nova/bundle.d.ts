import * as _135 from "./gal/v1/genesis";
import * as _136 from "./gal/v1/params";
import * as _137 from "./gal/v1/query";
import * as _138 from "./gal/v1/tx";
import * as _139 from "./ibcstaking/v1/genesis";
import * as _140 from "./ibcstaking/v1/params";
import * as _141 from "./ibcstaking/v1/query";
import * as _142 from "./ibcstaking/v1/tx";
import * as _143 from "./mint/v1/genesis";
import * as _144 from "./mint/v1/mint";
import * as _145 from "./mint/v1/query";
import * as _146 from "./oracle/v1/genesis";
import * as _147 from "./oracle/v1/params";
import * as _148 from "./oracle/v1/query";
import * as _149 from "./oracle/v1/tx";
import * as _268 from "./gal/v1/query.lcd";
import * as _269 from "./ibcstaking/v1/query.lcd";
import * as _270 from "./mint/v1/query.lcd";
import * as _271 from "./oracle/v1/query.lcd";
import * as _272 from "./gal/v1/query.rpc.query";
import * as _273 from "./ibcstaking/v1/query.rpc.query";
import * as _274 from "./mint/v1/query.rpc.query";
import * as _275 from "./oracle/v1/query.rpc.query";
import * as _276 from "./gal/v1/tx.rpc.msg";
import * as _277 from "./ibcstaking/v1/tx.rpc.msg";
import * as _278 from "./oracle/v1/tx.rpc.msg";
export declare namespace nova {
    namespace gal {
        const v1: {
            MsgClientImpl: typeof _276.MsgClientImpl;
            QueryClientImpl: typeof _272.QueryClientImpl;
            LCDQueryClient: typeof _268.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    deposit(value: _138.MsgDeposit): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    delegate(value: _138.MsgDelegate): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    undelegate(value: _138.MsgUndelegate): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    pendingUndelegate(value: _138.MsgPendingUndelegate): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    withdraw(value: _138.MsgWithdraw): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    claimSnAsset(value: _138.MsgClaimSnAsset): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    pendingWithdraw(value: _138.MsgPendingWithdraw): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    deposit(value: _138.MsgDeposit): {
                        typeUrl: string;
                        value: _138.MsgDeposit;
                    };
                    delegate(value: _138.MsgDelegate): {
                        typeUrl: string;
                        value: _138.MsgDelegate;
                    };
                    undelegate(value: _138.MsgUndelegate): {
                        typeUrl: string;
                        value: _138.MsgUndelegate;
                    };
                    pendingUndelegate(value: _138.MsgPendingUndelegate): {
                        typeUrl: string;
                        value: _138.MsgPendingUndelegate;
                    };
                    withdraw(value: _138.MsgWithdraw): {
                        typeUrl: string;
                        value: _138.MsgWithdraw;
                    };
                    claimSnAsset(value: _138.MsgClaimSnAsset): {
                        typeUrl: string;
                        value: _138.MsgClaimSnAsset;
                    };
                    pendingWithdraw(value: _138.MsgPendingWithdraw): {
                        typeUrl: string;
                        value: _138.MsgPendingWithdraw;
                    };
                };
                toJSON: {
                    deposit(value: _138.MsgDeposit): {
                        typeUrl: string;
                        value: unknown;
                    };
                    delegate(value: _138.MsgDelegate): {
                        typeUrl: string;
                        value: unknown;
                    };
                    undelegate(value: _138.MsgUndelegate): {
                        typeUrl: string;
                        value: unknown;
                    };
                    pendingUndelegate(value: _138.MsgPendingUndelegate): {
                        typeUrl: string;
                        value: unknown;
                    };
                    withdraw(value: _138.MsgWithdraw): {
                        typeUrl: string;
                        value: unknown;
                    };
                    claimSnAsset(value: _138.MsgClaimSnAsset): {
                        typeUrl: string;
                        value: unknown;
                    };
                    pendingWithdraw(value: _138.MsgPendingWithdraw): {
                        typeUrl: string;
                        value: unknown;
                    };
                };
                fromJSON: {
                    deposit(value: any): {
                        typeUrl: string;
                        value: _138.MsgDeposit;
                    };
                    delegate(value: any): {
                        typeUrl: string;
                        value: _138.MsgDelegate;
                    };
                    undelegate(value: any): {
                        typeUrl: string;
                        value: _138.MsgUndelegate;
                    };
                    pendingUndelegate(value: any): {
                        typeUrl: string;
                        value: _138.MsgPendingUndelegate;
                    };
                    withdraw(value: any): {
                        typeUrl: string;
                        value: _138.MsgWithdraw;
                    };
                    claimSnAsset(value: any): {
                        typeUrl: string;
                        value: _138.MsgClaimSnAsset;
                    };
                    pendingWithdraw(value: any): {
                        typeUrl: string;
                        value: _138.MsgPendingWithdraw;
                    };
                };
                fromPartial: {
                    deposit(value: _138.MsgDeposit): {
                        typeUrl: string;
                        value: _138.MsgDeposit;
                    };
                    delegate(value: _138.MsgDelegate): {
                        typeUrl: string;
                        value: _138.MsgDelegate;
                    };
                    undelegate(value: _138.MsgUndelegate): {
                        typeUrl: string;
                        value: _138.MsgUndelegate;
                    };
                    pendingUndelegate(value: _138.MsgPendingUndelegate): {
                        typeUrl: string;
                        value: _138.MsgPendingUndelegate;
                    };
                    withdraw(value: _138.MsgWithdraw): {
                        typeUrl: string;
                        value: _138.MsgWithdraw;
                    };
                    claimSnAsset(value: _138.MsgClaimSnAsset): {
                        typeUrl: string;
                        value: _138.MsgClaimSnAsset;
                    };
                    pendingWithdraw(value: _138.MsgPendingWithdraw): {
                        typeUrl: string;
                        value: _138.MsgPendingWithdraw;
                    };
                };
            };
            AminoConverter: {
                "/nova.gal.v1.MsgDeposit": {
                    aminoType: string;
                    toAmino: ({ zoneId, depositor, claimer, amount, transferPortId, transferChannelId }: _138.MsgDeposit) => {
                        zone_id: string;
                        depositor: string;
                        claimer: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    };
                    fromAmino: ({ zone_id, depositor, claimer, amount, transfer_port_id, transfer_channel_id }: {
                        zone_id: string;
                        depositor: string;
                        claimer: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    }) => _138.MsgDeposit;
                };
                "/nova.gal.v1.MsgDelegate": {
                    aminoType: string;
                    toAmino: ({ zoneId, controllerAddress, transferPortId, transferChannelId }: _138.MsgDelegate) => {
                        zone_id: string;
                        controller_address: string;
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    };
                    fromAmino: ({ zone_id, controller_address, transfer_port_id, transfer_channel_id }: {
                        zone_id: string;
                        controller_address: string;
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    }) => _138.MsgDelegate;
                };
                "/nova.gal.v1.MsgUndelegate": {
                    aminoType: string;
                    toAmino: ({ zoneId, controllerAddress }: _138.MsgUndelegate) => {
                        zone_id: string;
                        controller_address: string;
                    };
                    fromAmino: ({ zone_id, controller_address }: {
                        zone_id: string;
                        controller_address: string;
                    }) => _138.MsgUndelegate;
                };
                "/nova.gal.v1.MsgPendingUndelegate": {
                    aminoType: string;
                    toAmino: ({ zoneId, delegator, withdrawer, amount }: _138.MsgPendingUndelegate) => {
                        zone_id: string;
                        delegator: string;
                        withdrawer: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    };
                    fromAmino: ({ zone_id, delegator, withdrawer, amount }: {
                        zone_id: string;
                        delegator: string;
                        withdrawer: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    }) => _138.MsgPendingUndelegate;
                };
                "/nova.gal.v1.MsgWithdraw": {
                    aminoType: string;
                    toAmino: ({ zoneId, withdrawer, transferPortId, transferChannelId }: _138.MsgWithdraw) => {
                        zone_id: string;
                        withdrawer: string;
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    };
                    fromAmino: ({ zone_id, withdrawer, transfer_port_id, transfer_channel_id }: {
                        zone_id: string;
                        withdrawer: string;
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    }) => _138.MsgWithdraw;
                };
                "/nova.gal.v1.MsgClaimSnAsset": {
                    aminoType: string;
                    toAmino: ({ zoneId, claimer, transferPortId, transferChannelId }: _138.MsgClaimSnAsset) => {
                        zone_id: string;
                        claimer: string;
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    };
                    fromAmino: ({ zone_id, claimer, transfer_port_id, transfer_channel_id }: {
                        zone_id: string;
                        claimer: string;
                        transfer_port_id: string;
                        transfer_channel_id: string;
                    }) => _138.MsgClaimSnAsset;
                };
                "/nova.gal.v1.MsgPendingWithdraw": {
                    aminoType: string;
                    toAmino: ({ zoneId, controllerAddress, icaTransferPortId, icaTransferChannelId, chainTime }: _138.MsgPendingWithdraw) => {
                        zone_id: string;
                        controller_address: string;
                        ica_transfer_port_id: string;
                        ica_transfer_channel_id: string;
                        chain_time: {
                            seconds: string;
                            nanos: number;
                        };
                    };
                    fromAmino: ({ zone_id, controller_address, ica_transfer_port_id, ica_transfer_channel_id, chain_time }: {
                        zone_id: string;
                        controller_address: string;
                        ica_transfer_port_id: string;
                        ica_transfer_channel_id: string;
                        chain_time: {
                            seconds: string;
                            nanos: number;
                        };
                    }) => _138.MsgPendingWithdraw;
                };
            };
            MsgDeposit: {
                encode(message: _138.MsgDeposit, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgDeposit;
                fromJSON(object: any): _138.MsgDeposit;
                toJSON(message: _138.MsgDeposit): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    depositor?: string;
                    claimer?: string;
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                    transferPortId?: string;
                    transferChannelId?: string;
                }): _138.MsgDeposit;
            };
            MsgDepositResponse: {
                encode(message: _138.MsgDepositResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgDepositResponse;
                fromJSON(object: any): _138.MsgDepositResponse;
                toJSON(message: _138.MsgDepositResponse): unknown;
                fromPartial(object: {
                    receiver?: string;
                    depositor?: string;
                    depositedAmount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _138.MsgDepositResponse;
            };
            MsgDelegate: {
                encode(message: _138.MsgDelegate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgDelegate;
                fromJSON(object: any): _138.MsgDelegate;
                toJSON(message: _138.MsgDelegate): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    controllerAddress?: string;
                    transferPortId?: string;
                    transferChannelId?: string;
                }): _138.MsgDelegate;
            };
            MsgDelegateResponse: {
                encode(_: _138.MsgDelegateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgDelegateResponse;
                fromJSON(_: any): _138.MsgDelegateResponse;
                toJSON(_: _138.MsgDelegateResponse): unknown;
                fromPartial(_: {}): _138.MsgDelegateResponse;
            };
            MsgUndelegate: {
                encode(message: _138.MsgUndelegate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgUndelegate;
                fromJSON(object: any): _138.MsgUndelegate;
                toJSON(message: _138.MsgUndelegate): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    controllerAddress?: string;
                }): _138.MsgUndelegate;
            };
            MsgUndelegateResponse: {
                encode(message: _138.MsgUndelegateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgUndelegateResponse;
                fromJSON(object: any): _138.MsgUndelegateResponse;
                toJSON(message: _138.MsgUndelegateResponse): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    totalBurnAsset?: {
                        denom?: string;
                        amount?: string;
                    };
                    totalUndelegateAsset?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _138.MsgUndelegateResponse;
            };
            MsgPendingUndelegate: {
                encode(message: _138.MsgPendingUndelegate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgPendingUndelegate;
                fromJSON(object: any): _138.MsgPendingUndelegate;
                toJSON(message: _138.MsgPendingUndelegate): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    delegator?: string;
                    withdrawer?: string;
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _138.MsgPendingUndelegate;
            };
            MsgPendingUndelegateResponse: {
                encode(message: _138.MsgPendingUndelegateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgPendingUndelegateResponse;
                fromJSON(object: any): _138.MsgPendingUndelegateResponse;
                toJSON(message: _138.MsgPendingUndelegateResponse): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    delegator?: string;
                    withdrawer?: string;
                    burnAsset?: {
                        denom?: string;
                        amount?: string;
                    };
                    undelegateAsset?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _138.MsgPendingUndelegateResponse;
            };
            MsgWithdraw: {
                encode(message: _138.MsgWithdraw, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgWithdraw;
                fromJSON(object: any): _138.MsgWithdraw;
                toJSON(message: _138.MsgWithdraw): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    withdrawer?: string;
                    transferPortId?: string;
                    transferChannelId?: string;
                }): _138.MsgWithdraw;
            };
            MsgWithdrawResponse: {
                encode(message: _138.MsgWithdrawResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgWithdrawResponse;
                fromJSON(object: any): _138.MsgWithdrawResponse;
                toJSON(message: _138.MsgWithdrawResponse): unknown;
                fromPartial(object: {
                    withdrawer?: string;
                    withdrawAmount?: string;
                }): _138.MsgWithdrawResponse;
            };
            MsgClaimSnAsset: {
                encode(message: _138.MsgClaimSnAsset, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgClaimSnAsset;
                fromJSON(object: any): _138.MsgClaimSnAsset;
                toJSON(message: _138.MsgClaimSnAsset): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    claimer?: string;
                    transferPortId?: string;
                    transferChannelId?: string;
                }): _138.MsgClaimSnAsset;
            };
            MsgClaimSnAssetResponse: {
                encode(message: _138.MsgClaimSnAssetResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgClaimSnAssetResponse;
                fromJSON(object: any): _138.MsgClaimSnAssetResponse;
                toJSON(message: _138.MsgClaimSnAssetResponse): unknown;
                fromPartial(object: {
                    claimer?: string;
                    minted?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _138.MsgClaimSnAssetResponse;
            };
            MsgPendingWithdraw: {
                encode(message: _138.MsgPendingWithdraw, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgPendingWithdraw;
                fromJSON(object: any): _138.MsgPendingWithdraw;
                toJSON(message: _138.MsgPendingWithdraw): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    controllerAddress?: string;
                    icaTransferPortId?: string;
                    icaTransferChannelId?: string;
                    chainTime?: Date;
                }): _138.MsgPendingWithdraw;
            };
            MsgPendingWithdrawResponse: {
                encode(_: _138.MsgPendingWithdrawResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _138.MsgPendingWithdrawResponse;
                fromJSON(_: any): _138.MsgPendingWithdrawResponse;
                toJSON(_: _138.MsgPendingWithdrawResponse): unknown;
                fromPartial(_: {}): _138.MsgPendingWithdrawResponse;
            };
            QueryParamsRequest: {
                encode(_: _137.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryParamsRequest;
                fromJSON(_: any): _137.QueryParamsRequest;
                toJSON(_: _137.QueryParamsRequest): unknown;
                fromPartial(_: {}): _137.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _137.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryParamsResponse;
                fromJSON(object: any): _137.QueryParamsResponse;
                toJSON(message: _137.QueryParamsResponse): unknown;
                fromPartial(object: {
                    params?: {
                        whiteListedTokenDenoms?: {
                            [x: string]: string;
                        };
                        blocksPerYear?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                }): _137.QueryParamsResponse;
            };
            ClaimableAmountRequest: {
                encode(message: _137.ClaimableAmountRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.ClaimableAmountRequest;
                fromJSON(object: any): _137.ClaimableAmountRequest;
                toJSON(message: _137.ClaimableAmountRequest): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    address?: string;
                    transferPortId?: string;
                    transferChannelId?: string;
                }): _137.ClaimableAmountRequest;
            };
            ClaimableAmountResponse: {
                encode(message: _137.ClaimableAmountResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.ClaimableAmountResponse;
                fromJSON(object: any): _137.ClaimableAmountResponse;
                toJSON(message: _137.ClaimableAmountResponse): unknown;
                fromPartial(object: {
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _137.ClaimableAmountResponse;
            };
            PendingWithdrawalsRequest: {
                encode(message: _137.PendingWithdrawalsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.PendingWithdrawalsRequest;
                fromJSON(object: any): _137.PendingWithdrawalsRequest;
                toJSON(message: _137.PendingWithdrawalsRequest): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    address?: string;
                    transferPortId?: string;
                    transferChannelId?: string;
                }): _137.PendingWithdrawalsRequest;
            };
            PendingWithdrawalsResponse: {
                encode(message: _137.PendingWithdrawalsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.PendingWithdrawalsResponse;
                fromJSON(object: any): _137.PendingWithdrawalsResponse;
                toJSON(message: _137.PendingWithdrawalsResponse): unknown;
                fromPartial(object: {
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _137.PendingWithdrawalsResponse;
            };
            ActiveWithdrawalsRequest: {
                encode(message: _137.ActiveWithdrawalsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.ActiveWithdrawalsRequest;
                fromJSON(object: any): _137.ActiveWithdrawalsRequest;
                toJSON(message: _137.ActiveWithdrawalsRequest): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    address?: string;
                    transferPortId?: string;
                    transferChannelId?: string;
                }): _137.ActiveWithdrawalsRequest;
            };
            ActiveWithdrawalsResponse: {
                encode(message: _137.ActiveWithdrawalsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.ActiveWithdrawalsResponse;
                fromJSON(object: any): _137.ActiveWithdrawalsResponse;
                toJSON(message: _137.ActiveWithdrawalsResponse): unknown;
                fromPartial(object: {
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _137.ActiveWithdrawalsResponse;
            };
            QueryDepositRecordRequest: {
                encode(message: _137.QueryDepositRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryDepositRecordRequest;
                fromJSON(object: any): _137.QueryDepositRecordRequest;
                toJSON(message: _137.QueryDepositRecordRequest): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    address?: string;
                }): _137.QueryDepositRecordRequest;
            };
            QueryDepositRecordResponse: {
                encode(message: _137.QueryDepositRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryDepositRecordResponse;
                fromJSON(object: any): _137.QueryDepositRecordResponse;
                toJSON(message: _137.QueryDepositRecordResponse): unknown;
                fromPartial(object: {
                    depositRecord?: {
                        zoneId?: string;
                        claimer?: string;
                        records?: {
                            depositor?: string;
                            amount?: {
                                denom?: string;
                                amount?: string;
                            };
                            state?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                            oracleVersion?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                            delegateVersion?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                        }[];
                    };
                }): _137.QueryDepositRecordResponse;
            };
            QueryUndelegateRecordRequest: {
                encode(message: _137.QueryUndelegateRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryUndelegateRecordRequest;
                fromJSON(object: any): _137.QueryUndelegateRecordRequest;
                toJSON(message: _137.QueryUndelegateRecordRequest): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    address?: string;
                }): _137.QueryUndelegateRecordRequest;
            };
            QueryUndelegateRecordResponse: {
                encode(message: _137.QueryUndelegateRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryUndelegateRecordResponse;
                fromJSON(object: any): _137.QueryUndelegateRecordResponse;
                toJSON(message: _137.QueryUndelegateRecordResponse): unknown;
                fromPartial(object: {
                    undelegateRecord?: {
                        zoneId?: string;
                        delegator?: string;
                        records?: {
                            withdrawer?: string;
                            snAssetAmount?: {
                                denom?: string;
                                amount?: string;
                            };
                            withdrawAmount?: {
                                denom?: string;
                                amount?: string;
                            };
                            state?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                            oracleVersion?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                            undelegateVersion?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                        }[];
                    };
                }): _137.QueryUndelegateRecordResponse;
            };
            QueryWithdrawRecordRequest: {
                encode(message: _137.QueryWithdrawRecordRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryWithdrawRecordRequest;
                fromJSON(object: any): _137.QueryWithdrawRecordRequest;
                toJSON(message: _137.QueryWithdrawRecordRequest): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    address?: string;
                }): _137.QueryWithdrawRecordRequest;
            };
            QueryWithdrawRecordResponse: {
                encode(message: _137.QueryWithdrawRecordResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _137.QueryWithdrawRecordResponse;
                fromJSON(object: any): _137.QueryWithdrawRecordResponse;
                toJSON(message: _137.QueryWithdrawRecordResponse): unknown;
                fromPartial(object: {
                    withdrawRecord?: {
                        zoneId?: string;
                        withdrawer?: string;
                        records?: {};
                    };
                }): _137.QueryWithdrawRecordResponse;
            };
            Params_WhiteListedTokenDenomsEntry: {
                encode(message: _136.Params_WhiteListedTokenDenomsEntry, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _136.Params_WhiteListedTokenDenomsEntry;
                fromJSON(object: any): _136.Params_WhiteListedTokenDenomsEntry;
                toJSON(message: _136.Params_WhiteListedTokenDenomsEntry): unknown;
                fromPartial(object: {
                    key?: string;
                    value?: string;
                }): _136.Params_WhiteListedTokenDenomsEntry;
            };
            Params: {
                encode(message: _136.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _136.Params;
                fromJSON(object: any): _136.Params;
                toJSON(message: _136.Params): unknown;
                fromPartial(object: {
                    whiteListedTokenDenoms?: {
                        [x: string]: string;
                    };
                    blocksPerYear?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _136.Params;
            };
            GenesisState: {
                encode(message: _135.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.GenesisState;
                fromJSON(object: any): _135.GenesisState;
                toJSON(message: _135.GenesisState): unknown;
                fromPartial(object: {
                    params?: {
                        whiteListedTokenDenoms?: {
                            [x: string]: string;
                        };
                        blocksPerYear?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                    depositAccounts?: {
                        denom?: string;
                        depositInfos?: {
                            address?: string;
                            share?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                            debt?: {
                                high?: number;
                                low?: number;
                                unsigned?: boolean;
                                add?: (addend: string | number | import("long")) => import("long");
                                and?: (other: string | number | import("long")) => import("long");
                                compare?: (other: string | number | import("long")) => number;
                                comp?: (other: string | number | import("long")) => number;
                                divide?: (divisor: string | number | import("long")) => import("long");
                                div?: (divisor: string | number | import("long")) => import("long");
                                equals?: (other: string | number | import("long")) => boolean;
                                eq?: (other: string | number | import("long")) => boolean;
                                getHighBits?: () => number;
                                getHighBitsUnsigned?: () => number;
                                getLowBits?: () => number;
                                getLowBitsUnsigned?: () => number;
                                getNumBitsAbs?: () => number;
                                greaterThan?: (other: string | number | import("long")) => boolean;
                                gt?: (other: string | number | import("long")) => boolean;
                                greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                                gte?: (other: string | number | import("long")) => boolean;
                                ge?: (other: string | number | import("long")) => boolean;
                                isEven?: () => boolean;
                                isNegative?: () => boolean;
                                isOdd?: () => boolean;
                                isPositive?: () => boolean;
                                isZero?: () => boolean;
                                eqz?: () => boolean;
                                lessThan?: (other: string | number | import("long")) => boolean;
                                lt?: (other: string | number | import("long")) => boolean;
                                lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                                lte?: (other: string | number | import("long")) => boolean;
                                le?: (other: string | number | import("long")) => boolean;
                                modulo?: (other: string | number | import("long")) => import("long");
                                mod?: (other: string | number | import("long")) => import("long");
                                rem?: (other: string | number | import("long")) => import("long");
                                multiply?: (multiplier: string | number | import("long")) => import("long");
                                mul?: (multiplier: string | number | import("long")) => import("long");
                                negate?: () => import("long");
                                neg?: () => import("long");
                                not?: () => import("long");
                                countLeadingZeros?: () => number;
                                clz?: () => number;
                                countTrailingZeros?: () => number;
                                ctz?: () => number;
                                notEquals?: (other: string | number | import("long")) => boolean;
                                neq?: (other: string | number | import("long")) => boolean;
                                ne?: (other: string | number | import("long")) => boolean;
                                or?: (other: string | number | import("long")) => import("long");
                                shiftLeft?: (numBits: number | import("long")) => import("long");
                                shl?: (numBits: number | import("long")) => import("long");
                                shiftRight?: (numBits: number | import("long")) => import("long");
                                shr?: (numBits: number | import("long")) => import("long");
                                shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                                shru?: (numBits: number | import("long")) => import("long");
                                shr_u?: (numBits: number | import("long")) => import("long");
                                rotateLeft?: (numBits: number | import("long")) => import("long");
                                rotl?: (numBits: number | import("long")) => import("long");
                                rotateRight?: (numBits: number | import("long")) => import("long");
                                rotr?: (numBits: number | import("long")) => import("long");
                                subtract?: (subtrahend: string | number | import("long")) => import("long");
                                sub?: (subtrahend: string | number | import("long")) => import("long");
                                toInt?: () => number;
                                toNumber?: () => number;
                                toBytes?: (le?: boolean) => number[];
                                toBytesLE?: () => number[];
                                toBytesBE?: () => number[];
                                toSigned?: () => import("long");
                                toString?: (radix?: number) => string;
                                toUnsigned?: () => import("long");
                                xor?: (other: string | number | import("long")) => import("long");
                            };
                        }[];
                        totalShare?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        lastBlockUpdate?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    }[];
                    withdrawInfo?: {
                        address?: string;
                        denom?: string;
                        amount?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        completionTime?: Date;
                    }[];
                    recordInfo?: {
                        zoneId?: string;
                        delegateVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        undelegateVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        withdrawVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    }[];
                }): _135.GenesisState;
            };
            DepositAccount: {
                encode(message: _135.DepositAccount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.DepositAccount;
                fromJSON(object: any): _135.DepositAccount;
                toJSON(message: _135.DepositAccount): unknown;
                fromPartial(object: {
                    denom?: string;
                    depositInfos?: {
                        address?: string;
                        share?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        debt?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    }[];
                    totalShare?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    lastBlockUpdate?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _135.DepositAccount;
            };
            DepositInfo: {
                encode(message: _135.DepositInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.DepositInfo;
                fromJSON(object: any): _135.DepositInfo;
                toJSON(message: _135.DepositInfo): unknown;
                fromPartial(object: {
                    address?: string;
                    share?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    debt?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _135.DepositInfo;
            };
            WithdrawInfo: {
                encode(message: _135.WithdrawInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.WithdrawInfo;
                fromJSON(object: any): _135.WithdrawInfo;
                toJSON(message: _135.WithdrawInfo): unknown;
                fromPartial(object: {
                    address?: string;
                    denom?: string;
                    amount?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    completionTime?: Date;
                }): _135.WithdrawInfo;
            };
            RecordInfo: {
                encode(message: _135.RecordInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.RecordInfo;
                fromJSON(object: any): _135.RecordInfo;
                toJSON(message: _135.RecordInfo): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    delegateVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    undelegateVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    withdrawVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _135.RecordInfo;
            };
            DepositRecord: {
                encode(message: _135.DepositRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.DepositRecord;
                fromJSON(object: any): _135.DepositRecord;
                toJSON(message: _135.DepositRecord): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    claimer?: string;
                    records?: {
                        depositor?: string;
                        amount?: {
                            denom?: string;
                            amount?: string;
                        };
                        state?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        oracleVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        delegateVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    }[];
                }): _135.DepositRecord;
            };
            DepositRecordContent: {
                encode(message: _135.DepositRecordContent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.DepositRecordContent;
                fromJSON(object: any): _135.DepositRecordContent;
                toJSON(message: _135.DepositRecordContent): unknown;
                fromPartial(object: {
                    depositor?: string;
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                    state?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    oracleVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    delegateVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _135.DepositRecordContent;
            };
            UndelegateRecord: {
                encode(message: _135.UndelegateRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.UndelegateRecord;
                fromJSON(object: any): _135.UndelegateRecord;
                toJSON(message: _135.UndelegateRecord): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    delegator?: string;
                    records?: {
                        withdrawer?: string;
                        snAssetAmount?: {
                            denom?: string;
                            amount?: string;
                        };
                        withdrawAmount?: {
                            denom?: string;
                            amount?: string;
                        };
                        state?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        oracleVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        undelegateVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    }[];
                }): _135.UndelegateRecord;
            };
            UndelegateRecordContent: {
                encode(message: _135.UndelegateRecordContent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.UndelegateRecordContent;
                fromJSON(object: any): _135.UndelegateRecordContent;
                toJSON(message: _135.UndelegateRecordContent): unknown;
                fromPartial(object: {
                    withdrawer?: string;
                    snAssetAmount?: {
                        denom?: string;
                        amount?: string;
                    };
                    withdrawAmount?: {
                        denom?: string;
                        amount?: string;
                    };
                    state?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    oracleVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    undelegateVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _135.UndelegateRecordContent;
            };
            WithdrawRecord_RecordsEntry: {
                encode(message: _135.WithdrawRecord_RecordsEntry, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.WithdrawRecord_RecordsEntry;
                fromJSON(object: any): _135.WithdrawRecord_RecordsEntry;
                toJSON(message: _135.WithdrawRecord_RecordsEntry): unknown;
                fromPartial(object: {
                    key?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    value?: {
                        amount?: string;
                        state?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        oracleVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        withdrawVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        completionTime?: Date;
                    };
                }): _135.WithdrawRecord_RecordsEntry;
            };
            WithdrawRecord: {
                encode(message: _135.WithdrawRecord, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.WithdrawRecord;
                fromJSON(object: any): _135.WithdrawRecord;
                toJSON(message: _135.WithdrawRecord): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    withdrawer?: string;
                    records?: {};
                }): _135.WithdrawRecord;
            };
            WithdrawRecordContent: {
                encode(message: _135.WithdrawRecordContent, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _135.WithdrawRecordContent;
                fromJSON(object: any): _135.WithdrawRecordContent;
                toJSON(message: _135.WithdrawRecordContent): unknown;
                fromPartial(object: {
                    amount?: string;
                    state?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    oracleVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    withdrawVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    completionTime?: Date;
                }): _135.WithdrawRecordContent;
            };
        };
    }
    namespace ibcstaking {
        const v1: {
            MsgClientImpl: typeof _277.MsgClientImpl;
            QueryClientImpl: typeof _273.QueryClientImpl;
            LCDQueryClient: typeof _269.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    registerZone(value: _142.MsgRegisterZone): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    icaDelegate(value: _142.MsgIcaDelegate): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    icaUndelegate(value: _142.MsgIcaUndelegate): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    icaTransfer(value: _142.MsgIcaTransfer): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    icaAutoStaking(value: _142.MsgIcaAutoStaking): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    icaRegisterHostAccount(value: _142.MsgRegisterHostAccount): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    deleteRegisteredZone(value: _142.MsgDeleteRegisteredZone): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                    changeRegisteredZoneInfo(value: _142.MsgChangeRegisteredZoneInfo): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    registerZone(value: _142.MsgRegisterZone): {
                        typeUrl: string;
                        value: _142.MsgRegisterZone;
                    };
                    icaDelegate(value: _142.MsgIcaDelegate): {
                        typeUrl: string;
                        value: _142.MsgIcaDelegate;
                    };
                    icaUndelegate(value: _142.MsgIcaUndelegate): {
                        typeUrl: string;
                        value: _142.MsgIcaUndelegate;
                    };
                    icaTransfer(value: _142.MsgIcaTransfer): {
                        typeUrl: string;
                        value: _142.MsgIcaTransfer;
                    };
                    icaAutoStaking(value: _142.MsgIcaAutoStaking): {
                        typeUrl: string;
                        value: _142.MsgIcaAutoStaking;
                    };
                    icaRegisterHostAccount(value: _142.MsgRegisterHostAccount): {
                        typeUrl: string;
                        value: _142.MsgRegisterHostAccount;
                    };
                    deleteRegisteredZone(value: _142.MsgDeleteRegisteredZone): {
                        typeUrl: string;
                        value: _142.MsgDeleteRegisteredZone;
                    };
                    changeRegisteredZoneInfo(value: _142.MsgChangeRegisteredZoneInfo): {
                        typeUrl: string;
                        value: _142.MsgChangeRegisteredZoneInfo;
                    };
                };
                toJSON: {
                    registerZone(value: _142.MsgRegisterZone): {
                        typeUrl: string;
                        value: unknown;
                    };
                    icaDelegate(value: _142.MsgIcaDelegate): {
                        typeUrl: string;
                        value: unknown;
                    };
                    icaUndelegate(value: _142.MsgIcaUndelegate): {
                        typeUrl: string;
                        value: unknown;
                    };
                    icaTransfer(value: _142.MsgIcaTransfer): {
                        typeUrl: string;
                        value: unknown;
                    };
                    icaAutoStaking(value: _142.MsgIcaAutoStaking): {
                        typeUrl: string;
                        value: unknown;
                    };
                    icaRegisterHostAccount(value: _142.MsgRegisterHostAccount): {
                        typeUrl: string;
                        value: unknown;
                    };
                    deleteRegisteredZone(value: _142.MsgDeleteRegisteredZone): {
                        typeUrl: string;
                        value: unknown;
                    };
                    changeRegisteredZoneInfo(value: _142.MsgChangeRegisteredZoneInfo): {
                        typeUrl: string;
                        value: unknown;
                    };
                };
                fromJSON: {
                    registerZone(value: any): {
                        typeUrl: string;
                        value: _142.MsgRegisterZone;
                    };
                    icaDelegate(value: any): {
                        typeUrl: string;
                        value: _142.MsgIcaDelegate;
                    };
                    icaUndelegate(value: any): {
                        typeUrl: string;
                        value: _142.MsgIcaUndelegate;
                    };
                    icaTransfer(value: any): {
                        typeUrl: string;
                        value: _142.MsgIcaTransfer;
                    };
                    icaAutoStaking(value: any): {
                        typeUrl: string;
                        value: _142.MsgIcaAutoStaking;
                    };
                    icaRegisterHostAccount(value: any): {
                        typeUrl: string;
                        value: _142.MsgRegisterHostAccount;
                    };
                    deleteRegisteredZone(value: any): {
                        typeUrl: string;
                        value: _142.MsgDeleteRegisteredZone;
                    };
                    changeRegisteredZoneInfo(value: any): {
                        typeUrl: string;
                        value: _142.MsgChangeRegisteredZoneInfo;
                    };
                };
                fromPartial: {
                    registerZone(value: _142.MsgRegisterZone): {
                        typeUrl: string;
                        value: _142.MsgRegisterZone;
                    };
                    icaDelegate(value: _142.MsgIcaDelegate): {
                        typeUrl: string;
                        value: _142.MsgIcaDelegate;
                    };
                    icaUndelegate(value: _142.MsgIcaUndelegate): {
                        typeUrl: string;
                        value: _142.MsgIcaUndelegate;
                    };
                    icaTransfer(value: _142.MsgIcaTransfer): {
                        typeUrl: string;
                        value: _142.MsgIcaTransfer;
                    };
                    icaAutoStaking(value: _142.MsgIcaAutoStaking): {
                        typeUrl: string;
                        value: _142.MsgIcaAutoStaking;
                    };
                    icaRegisterHostAccount(value: _142.MsgRegisterHostAccount): {
                        typeUrl: string;
                        value: _142.MsgRegisterHostAccount;
                    };
                    deleteRegisteredZone(value: _142.MsgDeleteRegisteredZone): {
                        typeUrl: string;
                        value: _142.MsgDeleteRegisteredZone;
                    };
                    changeRegisteredZoneInfo(value: _142.MsgChangeRegisteredZoneInfo): {
                        typeUrl: string;
                        value: _142.MsgChangeRegisteredZoneInfo;
                    };
                };
            };
            AminoConverter: {
                "/nova.ibcstaking.v1.MsgRegisterZone": {
                    aminoType: string;
                    toAmino: ({ zoneId, icaInfo, icaAccount, validatorAddress, baseDenom, decimal }: _142.MsgRegisterZone) => {
                        zone_id: string;
                        ica_info: {
                            connection_id: string;
                            port_id: string;
                        };
                        ica_account: {
                            daomodifier_address: string;
                            host_address: string;
                            balance: {
                                denom: string;
                                amount: string;
                            };
                        };
                        validator_address: string;
                        base_denom: string;
                        decimal: string;
                    };
                    fromAmino: ({ zone_id, ica_info, ica_account, validator_address, base_denom, decimal }: {
                        zone_id: string;
                        ica_info: {
                            connection_id: string;
                            port_id: string;
                        };
                        ica_account: {
                            daomodifier_address: string;
                            host_address: string;
                            balance: {
                                denom: string;
                                amount: string;
                            };
                        };
                        validator_address: string;
                        base_denom: string;
                        decimal: string;
                    }) => _142.MsgRegisterZone;
                };
                "/nova.ibcstaking.v1.MsgIcaDelegate": {
                    aminoType: string;
                    toAmino: ({ zoneId, hostAddress, daomodifierAddress, amount }: _142.MsgIcaDelegate) => {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    };
                    fromAmino: ({ zone_id, host_address, daomodifier_address, amount }: {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    }) => _142.MsgIcaDelegate;
                };
                "/nova.ibcstaking.v1.MsgIcaUndelegate": {
                    aminoType: string;
                    toAmino: ({ zoneId, hostAddress, daomodifierAddress, amount }: _142.MsgIcaUndelegate) => {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    };
                    fromAmino: ({ zone_id, host_address, daomodifier_address, amount }: {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    }) => _142.MsgIcaUndelegate;
                };
                "/nova.ibcstaking.v1.MsgIcaTransfer": {
                    aminoType: string;
                    toAmino: ({ zoneId, hostAddress, daomodifierAddress, receiverAddress, icaTransferPortId, icaTransferChannelId, amount }: _142.MsgIcaTransfer) => {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        receiver_address: string;
                        ica_transfer_port_id: string;
                        ica_transfer_channel_id: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    };
                    fromAmino: ({ zone_id, host_address, daomodifier_address, receiver_address, ica_transfer_port_id, ica_transfer_channel_id, amount }: {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        receiver_address: string;
                        ica_transfer_port_id: string;
                        ica_transfer_channel_id: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    }) => _142.MsgIcaTransfer;
                };
                "/nova.ibcstaking.v1.MsgIcaAutoStaking": {
                    aminoType: string;
                    toAmino: ({ zoneId, hostAddress, daomodifierAddress, amount }: _142.MsgIcaAutoStaking) => {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    };
                    fromAmino: ({ zone_id, host_address, daomodifier_address, amount }: {
                        zone_id: string;
                        host_address: string;
                        daomodifier_address: string;
                        amount: {
                            denom: string;
                            amount: string;
                        };
                    }) => _142.MsgIcaAutoStaking;
                };
                "/nova.ibcstaking.v1.MsgRegisterHostAccount": {
                    aminoType: string;
                    toAmino: ({ zoneId, accountInfo }: _142.MsgRegisterHostAccount) => {
                        zone_id: string;
                        account_info: {
                            daomodifier_address: string;
                            host_address: string;
                            balance: {
                                denom: string;
                                amount: string;
                            };
                        };
                    };
                    fromAmino: ({ zone_id, account_info }: {
                        zone_id: string;
                        account_info: {
                            daomodifier_address: string;
                            host_address: string;
                            balance: {
                                denom: string;
                                amount: string;
                            };
                        };
                    }) => _142.MsgRegisterHostAccount;
                };
                "/nova.ibcstaking.v1.MsgDeleteRegisteredZone": {
                    aminoType: string;
                    toAmino: ({ zoneId, daomodifierAddress }: _142.MsgDeleteRegisteredZone) => {
                        zone_id: string;
                        daomodifier_address: string;
                    };
                    fromAmino: ({ zone_id, daomodifier_address }: {
                        zone_id: string;
                        daomodifier_address: string;
                    }) => _142.MsgDeleteRegisteredZone;
                };
                "/nova.ibcstaking.v1.MsgChangeRegisteredZoneInfo": {
                    aminoType: string;
                    toAmino: ({ zoneId, icaInfo, icaAccount, validatorAddress, baseDenom, decimal }: _142.MsgChangeRegisteredZoneInfo) => {
                        zone_id: string;
                        ica_info: {
                            connection_id: string;
                            port_id: string;
                        };
                        ica_account: {
                            daomodifier_address: string;
                            host_address: string;
                            balance: {
                                denom: string;
                                amount: string;
                            };
                        };
                        validator_address: string;
                        base_denom: string;
                        decimal: string;
                    };
                    fromAmino: ({ zone_id, ica_info, ica_account, validator_address, base_denom, decimal }: {
                        zone_id: string;
                        ica_info: {
                            connection_id: string;
                            port_id: string;
                        };
                        ica_account: {
                            daomodifier_address: string;
                            host_address: string;
                            balance: {
                                denom: string;
                                amount: string;
                            };
                        };
                        validator_address: string;
                        base_denom: string;
                        decimal: string;
                    }) => _142.MsgChangeRegisteredZoneInfo;
                };
            };
            MsgRegisterZone: {
                encode(message: _142.MsgRegisterZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgRegisterZone;
                fromJSON(object: any): _142.MsgRegisterZone;
                toJSON(message: _142.MsgRegisterZone): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    icaInfo?: {
                        connectionId?: string;
                        portId?: string;
                    };
                    icaAccount?: {
                        daomodifierAddress?: string;
                        hostAddress?: string;
                        balance?: {
                            denom?: string;
                            amount?: string;
                        };
                    };
                    validatorAddress?: string;
                    baseDenom?: string;
                    decimal?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _142.MsgRegisterZone;
            };
            MsgRegisterZoneResponse: {
                encode(_: _142.MsgRegisterZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgRegisterZoneResponse;
                fromJSON(_: any): _142.MsgRegisterZoneResponse;
                toJSON(_: _142.MsgRegisterZoneResponse): unknown;
                fromPartial(_: {}): _142.MsgRegisterZoneResponse;
            };
            MsgChangeRegisteredZoneInfo: {
                encode(message: _142.MsgChangeRegisteredZoneInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgChangeRegisteredZoneInfo;
                fromJSON(object: any): _142.MsgChangeRegisteredZoneInfo;
                toJSON(message: _142.MsgChangeRegisteredZoneInfo): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    icaInfo?: {
                        connectionId?: string;
                        portId?: string;
                    };
                    icaAccount?: {
                        daomodifierAddress?: string;
                        hostAddress?: string;
                        balance?: {
                            denom?: string;
                            amount?: string;
                        };
                    };
                    validatorAddress?: string;
                    baseDenom?: string;
                    decimal?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _142.MsgChangeRegisteredZoneInfo;
            };
            MsgChangeRegisteredZoneInfoResponse: {
                encode(_: _142.MsgChangeRegisteredZoneInfoResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgChangeRegisteredZoneInfoResponse;
                fromJSON(_: any): _142.MsgChangeRegisteredZoneInfoResponse;
                toJSON(_: _142.MsgChangeRegisteredZoneInfoResponse): unknown;
                fromPartial(_: {}): _142.MsgChangeRegisteredZoneInfoResponse;
            };
            MsgDeleteRegisteredZone: {
                encode(message: _142.MsgDeleteRegisteredZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgDeleteRegisteredZone;
                fromJSON(object: any): _142.MsgDeleteRegisteredZone;
                toJSON(message: _142.MsgDeleteRegisteredZone): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    daomodifierAddress?: string;
                }): _142.MsgDeleteRegisteredZone;
            };
            MsgDeleteRegisteredZoneResponse: {
                encode(_: _142.MsgDeleteRegisteredZoneResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgDeleteRegisteredZoneResponse;
                fromJSON(_: any): _142.MsgDeleteRegisteredZoneResponse;
                toJSON(_: _142.MsgDeleteRegisteredZoneResponse): unknown;
                fromPartial(_: {}): _142.MsgDeleteRegisteredZoneResponse;
            };
            MsgIcaDelegate: {
                encode(message: _142.MsgIcaDelegate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaDelegate;
                fromJSON(object: any): _142.MsgIcaDelegate;
                toJSON(message: _142.MsgIcaDelegate): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    hostAddress?: string;
                    daomodifierAddress?: string;
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _142.MsgIcaDelegate;
            };
            MsgIcaDelegateResponse: {
                encode(_: _142.MsgIcaDelegateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaDelegateResponse;
                fromJSON(_: any): _142.MsgIcaDelegateResponse;
                toJSON(_: _142.MsgIcaDelegateResponse): unknown;
                fromPartial(_: {}): _142.MsgIcaDelegateResponse;
            };
            MsgIcaUndelegate: {
                encode(message: _142.MsgIcaUndelegate, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaUndelegate;
                fromJSON(object: any): _142.MsgIcaUndelegate;
                toJSON(message: _142.MsgIcaUndelegate): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    hostAddress?: string;
                    daomodifierAddress?: string;
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _142.MsgIcaUndelegate;
            };
            MsgIcaUndelegateResponse: {
                encode(_: _142.MsgIcaUndelegateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaUndelegateResponse;
                fromJSON(_: any): _142.MsgIcaUndelegateResponse;
                toJSON(_: _142.MsgIcaUndelegateResponse): unknown;
                fromPartial(_: {}): _142.MsgIcaUndelegateResponse;
            };
            MsgIcaAutoStaking: {
                encode(message: _142.MsgIcaAutoStaking, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaAutoStaking;
                fromJSON(object: any): _142.MsgIcaAutoStaking;
                toJSON(message: _142.MsgIcaAutoStaking): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    hostAddress?: string;
                    daomodifierAddress?: string;
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _142.MsgIcaAutoStaking;
            };
            MsgIcaAutoStakingResponse: {
                encode(_: _142.MsgIcaAutoStakingResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaAutoStakingResponse;
                fromJSON(_: any): _142.MsgIcaAutoStakingResponse;
                toJSON(_: _142.MsgIcaAutoStakingResponse): unknown;
                fromPartial(_: {}): _142.MsgIcaAutoStakingResponse;
            };
            MsgIcaTransfer: {
                encode(message: _142.MsgIcaTransfer, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaTransfer;
                fromJSON(object: any): _142.MsgIcaTransfer;
                toJSON(message: _142.MsgIcaTransfer): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    hostAddress?: string;
                    daomodifierAddress?: string;
                    receiverAddress?: string;
                    icaTransferPortId?: string;
                    icaTransferChannelId?: string;
                    amount?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _142.MsgIcaTransfer;
            };
            MsgIcaTransferResponse: {
                encode(_: _142.MsgIcaTransferResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgIcaTransferResponse;
                fromJSON(_: any): _142.MsgIcaTransferResponse;
                toJSON(_: _142.MsgIcaTransferResponse): unknown;
                fromPartial(_: {}): _142.MsgIcaTransferResponse;
            };
            MsgRegisterHostAccount: {
                encode(message: _142.MsgRegisterHostAccount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgRegisterHostAccount;
                fromJSON(object: any): _142.MsgRegisterHostAccount;
                toJSON(message: _142.MsgRegisterHostAccount): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    accountInfo?: {
                        daomodifierAddress?: string;
                        hostAddress?: string;
                        balance?: {
                            denom?: string;
                            amount?: string;
                        };
                    };
                }): _142.MsgRegisterHostAccount;
            };
            MsgRegisterHostAccountResponse: {
                encode(_: _142.MsgRegisterHostAccountResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _142.MsgRegisterHostAccountResponse;
                fromJSON(_: any): _142.MsgRegisterHostAccountResponse;
                toJSON(_: _142.MsgRegisterHostAccountResponse): unknown;
                fromPartial(_: {}): _142.MsgRegisterHostAccountResponse;
            };
            QueryAllZonesRequest: {
                encode(_: _141.QueryAllZonesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _141.QueryAllZonesRequest;
                fromJSON(_: any): _141.QueryAllZonesRequest;
                toJSON(_: _141.QueryAllZonesRequest): unknown;
                fromPartial(_: {}): _141.QueryAllZonesRequest;
            };
            QueryAllZonesResponse: {
                encode(message: _141.QueryAllZonesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _141.QueryAllZonesResponse;
                fromJSON(object: any): _141.QueryAllZonesResponse;
                toJSON(message: _141.QueryAllZonesResponse): unknown;
                fromPartial(object: {
                    zones?: {
                        zoneId?: string;
                        icaConnectionInfo?: {
                            connectionId?: string;
                            portId?: string;
                        };
                        icaAccount?: {
                            daomodifierAddress?: string;
                            hostAddress?: string;
                            balance?: {
                                denom?: string;
                                amount?: string;
                            };
                        };
                        validatorAddress?: string;
                        baseDenom?: string;
                        snDenom?: string;
                        decimal?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    }[];
                }): _141.QueryAllZonesResponse;
            };
            Params: {
                encode(message: _140.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _140.Params;
                fromJSON(object: any): _140.Params;
                toJSON(message: _140.Params): unknown;
                fromPartial(object: {
                    daoModifiers?: string[];
                    commission?: {
                        treasuryAddress?: string;
                        commissionRate?: string;
                    }[];
                }): _140.Params;
            };
            CommissionInfo: {
                encode(message: _140.CommissionInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _140.CommissionInfo;
                fromJSON(object: any): _140.CommissionInfo;
                toJSON(message: _140.CommissionInfo): unknown;
                fromPartial(object: {
                    treasuryAddress?: string;
                    commissionRate?: string;
                }): _140.CommissionInfo;
            };
            GenesisState: {
                encode(message: _139.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _139.GenesisState;
                fromJSON(object: any): _139.GenesisState;
                toJSON(message: _139.GenesisState): unknown;
                fromPartial(object: {
                    params?: {
                        daoModifiers?: string[];
                        commission?: {
                            treasuryAddress?: string;
                            commissionRate?: string;
                        }[];
                    };
                }): _139.GenesisState;
            };
            RegisteredZone: {
                encode(message: _139.RegisteredZone, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _139.RegisteredZone;
                fromJSON(object: any): _139.RegisteredZone;
                toJSON(message: _139.RegisteredZone): unknown;
                fromPartial(object: {
                    zoneId?: string;
                    icaConnectionInfo?: {
                        connectionId?: string;
                        portId?: string;
                    };
                    icaAccount?: {
                        daomodifierAddress?: string;
                        hostAddress?: string;
                        balance?: {
                            denom?: string;
                            amount?: string;
                        };
                    };
                    validatorAddress?: string;
                    baseDenom?: string;
                    snDenom?: string;
                    decimal?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _139.RegisteredZone;
            };
            IcaAccount: {
                encode(message: _139.IcaAccount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _139.IcaAccount;
                fromJSON(object: any): _139.IcaAccount;
                toJSON(message: _139.IcaAccount): unknown;
                fromPartial(object: {
                    daomodifierAddress?: string;
                    hostAddress?: string;
                    balance?: {
                        denom?: string;
                        amount?: string;
                    };
                }): _139.IcaAccount;
            };
            IcaConnectionInfo: {
                encode(message: _139.IcaConnectionInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _139.IcaConnectionInfo;
                fromJSON(object: any): _139.IcaConnectionInfo;
                toJSON(message: _139.IcaConnectionInfo): unknown;
                fromPartial(object: {
                    connectionId?: string;
                    portId?: string;
                }): _139.IcaConnectionInfo;
            };
        };
    }
    namespace mint {
        const v1: {
            QueryClientImpl: typeof _274.QueryClientImpl;
            LCDQueryClient: typeof _270.LCDQueryClient;
            QueryParamsRequest: {
                encode(_: _145.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.QueryParamsRequest;
                fromJSON(_: any): _145.QueryParamsRequest;
                toJSON(_: _145.QueryParamsRequest): unknown;
                fromPartial(_: {}): _145.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _145.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.QueryParamsResponse;
                fromJSON(object: any): _145.QueryParamsResponse;
                toJSON(message: _145.QueryParamsResponse): unknown;
                fromPartial(object: {
                    params?: {
                        mintDenom?: string;
                        inflationRateChange?: string;
                        inflationMax?: string;
                        inflationMin?: string;
                        goalBonded?: string;
                        blocksPerYear?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        distributionProportions?: {
                            staking?: string;
                            lpIncentives?: string;
                            stableGuaranteeIncentives?: string;
                            communityPool?: string;
                        };
                    };
                }): _145.QueryParamsResponse;
            };
            QueryInflationRequest: {
                encode(_: _145.QueryInflationRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.QueryInflationRequest;
                fromJSON(_: any): _145.QueryInflationRequest;
                toJSON(_: _145.QueryInflationRequest): unknown;
                fromPartial(_: {}): _145.QueryInflationRequest;
            };
            QueryInflationResponse: {
                encode(message: _145.QueryInflationResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.QueryInflationResponse;
                fromJSON(object: any): _145.QueryInflationResponse;
                toJSON(message: _145.QueryInflationResponse): unknown;
                fromPartial(object: {
                    inflation?: Uint8Array;
                }): _145.QueryInflationResponse;
            };
            QueryAnnualProvisionsRequest: {
                encode(_: _145.QueryAnnualProvisionsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.QueryAnnualProvisionsRequest;
                fromJSON(_: any): _145.QueryAnnualProvisionsRequest;
                toJSON(_: _145.QueryAnnualProvisionsRequest): unknown;
                fromPartial(_: {}): _145.QueryAnnualProvisionsRequest;
            };
            QueryAnnualProvisionsResponse: {
                encode(message: _145.QueryAnnualProvisionsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _145.QueryAnnualProvisionsResponse;
                fromJSON(object: any): _145.QueryAnnualProvisionsResponse;
                toJSON(message: _145.QueryAnnualProvisionsResponse): unknown;
                fromPartial(object: {
                    annualProvisions?: Uint8Array;
                }): _145.QueryAnnualProvisionsResponse;
            };
            Minter: {
                encode(message: _144.Minter, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _144.Minter;
                fromJSON(object: any): _144.Minter;
                toJSON(message: _144.Minter): unknown;
                fromPartial(object: {
                    inflation?: string;
                    annualProvisions?: string;
                }): _144.Minter;
            };
            DistributionProportions: {
                encode(message: _144.DistributionProportions, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _144.DistributionProportions;
                fromJSON(object: any): _144.DistributionProportions;
                toJSON(message: _144.DistributionProportions): unknown;
                fromPartial(object: {
                    staking?: string;
                    lpIncentives?: string;
                    stableGuaranteeIncentives?: string;
                    communityPool?: string;
                }): _144.DistributionProportions;
            };
            Params: {
                encode(message: _144.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _144.Params;
                fromJSON(object: any): _144.Params;
                toJSON(message: _144.Params): unknown;
                fromPartial(object: {
                    mintDenom?: string;
                    inflationRateChange?: string;
                    inflationMax?: string;
                    inflationMin?: string;
                    goalBonded?: string;
                    blocksPerYear?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    distributionProportions?: {
                        staking?: string;
                        lpIncentives?: string;
                        stableGuaranteeIncentives?: string;
                        communityPool?: string;
                    };
                }): _144.Params;
            };
            GenesisState: {
                encode(message: _143.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _143.GenesisState;
                fromJSON(object: any): _143.GenesisState;
                toJSON(message: _143.GenesisState): unknown;
                fromPartial(object: {
                    minter?: {
                        inflation?: string;
                        annualProvisions?: string;
                    };
                    params?: {
                        mintDenom?: string;
                        inflationRateChange?: string;
                        inflationMax?: string;
                        inflationMin?: string;
                        goalBonded?: string;
                        blocksPerYear?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        distributionProportions?: {
                            staking?: string;
                            lpIncentives?: string;
                            stableGuaranteeIncentives?: string;
                            communityPool?: string;
                        };
                    };
                }): _143.GenesisState;
            };
        };
    }
    namespace oracle {
        const v1: {
            MsgClientImpl: typeof _278.MsgClientImpl;
            QueryClientImpl: typeof _275.QueryClientImpl;
            LCDQueryClient: typeof _271.LCDQueryClient;
            registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
            load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
            MessageComposer: {
                encoded: {
                    updateChainState(value: _149.MsgUpdateChainState): {
                        typeUrl: string;
                        value: Uint8Array;
                    };
                };
                withTypeUrl: {
                    updateChainState(value: _149.MsgUpdateChainState): {
                        typeUrl: string;
                        value: _149.MsgUpdateChainState;
                    };
                };
                toJSON: {
                    updateChainState(value: _149.MsgUpdateChainState): {
                        typeUrl: string;
                        value: unknown;
                    };
                };
                fromJSON: {
                    updateChainState(value: any): {
                        typeUrl: string;
                        value: _149.MsgUpdateChainState;
                    };
                };
                fromPartial: {
                    updateChainState(value: _149.MsgUpdateChainState): {
                        typeUrl: string;
                        value: _149.MsgUpdateChainState;
                    };
                };
            };
            AminoConverter: {
                "/nova.oracle.v1.MsgUpdateChainState": {
                    aminoType: string;
                    toAmino: ({ coin, operator, blockHeight, appHash, chainId }: _149.MsgUpdateChainState) => {
                        coin: {
                            denom: string;
                            amount: string;
                        };
                        operator: string;
                        block_height: string;
                        app_hash: Uint8Array;
                        chain_id: string;
                    };
                    fromAmino: ({ coin, operator, block_height, app_hash, chain_id }: {
                        coin: {
                            denom: string;
                            amount: string;
                        };
                        operator: string;
                        block_height: string;
                        app_hash: Uint8Array;
                        chain_id: string;
                    }) => _149.MsgUpdateChainState;
                };
            };
            MsgUpdateChainState: {
                encode(message: _149.MsgUpdateChainState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _149.MsgUpdateChainState;
                fromJSON(object: any): _149.MsgUpdateChainState;
                toJSON(message: _149.MsgUpdateChainState): unknown;
                fromPartial(object: {
                    coin?: {
                        denom?: string;
                        amount?: string;
                    };
                    operator?: string;
                    blockHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    appHash?: Uint8Array;
                    chainId?: string;
                }): _149.MsgUpdateChainState;
            };
            MsgUpdateChainStateResponse: {
                encode(message: _149.MsgUpdateChainStateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _149.MsgUpdateChainStateResponse;
                fromJSON(object: any): _149.MsgUpdateChainStateResponse;
                toJSON(message: _149.MsgUpdateChainStateResponse): unknown;
                fromPartial(object: {
                    success?: boolean;
                }): _149.MsgUpdateChainStateResponse;
            };
            QueryParamsRequest: {
                encode(_: _148.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryParamsRequest;
                fromJSON(_: any): _148.QueryParamsRequest;
                toJSON(_: _148.QueryParamsRequest): unknown;
                fromPartial(_: {}): _148.QueryParamsRequest;
            };
            QueryParamsResponse: {
                encode(message: _148.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryParamsResponse;
                fromJSON(object: any): _148.QueryParamsResponse;
                toJSON(message: _148.QueryParamsResponse): unknown;
                fromPartial(object: {
                    params?: {
                        oracleOperators?: string[];
                    };
                }): _148.QueryParamsResponse;
            };
            QueryStateRequest: {
                encode(message: _148.QueryStateRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryStateRequest;
                fromJSON(object: any): _148.QueryStateRequest;
                toJSON(message: _148.QueryStateRequest): unknown;
                fromPartial(object: {
                    chainDenom?: string;
                }): _148.QueryStateRequest;
            };
            QueryStateResponse: {
                encode(message: _148.QueryStateResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _148.QueryStateResponse;
                fromJSON(object: any): _148.QueryStateResponse;
                toJSON(message: _148.QueryStateResponse): unknown;
                fromPartial(object: {
                    coin?: {
                        denom?: string;
                        amount?: string;
                    };
                    operator?: string;
                    decimal?: number;
                    lastBlockHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    appHash?: Uint8Array;
                    chainId?: string;
                }): _148.QueryStateResponse;
            };
            Params: {
                encode(message: _147.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _147.Params;
                fromJSON(object: any): _147.Params;
                toJSON(message: _147.Params): unknown;
                fromPartial(object: {
                    oracleOperators?: string[];
                }): _147.Params;
            };
            GenesisState: {
                encode(message: _146.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _146.GenesisState;
                fromJSON(object: any): _146.GenesisState;
                toJSON(message: _146.GenesisState): unknown;
                fromPartial(object: {
                    params?: {
                        oracleOperators?: string[];
                    };
                    states?: {
                        coin?: {
                            denom?: string;
                            amount?: string;
                        };
                        operatorAddress?: string;
                        lastBlockHeight?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        appHash?: Uint8Array;
                        chainId?: string;
                        oracleVersion?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    }[];
                }): _146.GenesisState;
            };
            ChainInfo: {
                encode(message: _146.ChainInfo, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
                decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _146.ChainInfo;
                fromJSON(object: any): _146.ChainInfo;
                toJSON(message: _146.ChainInfo): unknown;
                fromPartial(object: {
                    coin?: {
                        denom?: string;
                        amount?: string;
                    };
                    operatorAddress?: string;
                    lastBlockHeight?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    appHash?: Uint8Array;
                    chainId?: string;
                    oracleVersion?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                }): _146.ChainInfo;
            };
        };
    }
    const ClientFactory: {
        createRPCMsgClient: ({ rpc }: {
            rpc: import("@osmonauts/helpers").Rpc;
        }) => Promise<{
            cosmos: {
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                crisis: {
                    v1beta1: import("../cosmos/crisis/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                gov: {
                    v1: import("../cosmos/gov/v1/tx.rpc.msg").MsgClientImpl;
                    v1beta1: import("../cosmos/gov/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                group: {
                    v1: import("../cosmos/group/v1/tx.rpc.msg").MsgClientImpl;
                };
                nft: {
                    v1beta1: import("../cosmos/nft/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                vesting: {
                    v1beta1: import("../cosmos/vesting/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
            };
            nova: {
                gal: {
                    v1: _276.MsgClientImpl;
                };
                ibcstaking: {
                    v1: _277.MsgClientImpl;
                };
                oracle: {
                    v1: _278.MsgClientImpl;
                };
            };
        }>;
        createRPCQueryClient: ({ rpc }: {
            rpc: import("@osmonauts/helpers").Rpc;
        }) => Promise<{
            cosmos: {
                app: {
                    v1alpha1: import("../cosmos/app/v1alpha1/query.rpc.query").QueryClientImpl;
                };
                auth: {
                    v1beta1: import("../cosmos/auth/v1beta1/query.rpc.query").QueryClientImpl;
                };
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/query.rpc.query").QueryClientImpl;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/query.rpc.query").QueryClientImpl;
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/query.rpc.query").QueryClientImpl;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/query.rpc.query").QueryClientImpl;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/query.rpc.query").QueryClientImpl;
                };
                gov: {
                    v1: import("../cosmos/gov/v1/query.rpc.query").QueryClientImpl;
                    v1beta1: import("../cosmos/gov/v1beta1/query.rpc.query").QueryClientImpl;
                };
                group: {
                    v1: import("../cosmos/group/v1/query.rpc.query").QueryClientImpl;
                };
                mint: {
                    v1beta1: import("../cosmos/mint/v1beta1/query.rpc.query").QueryClientImpl;
                };
                nft: {
                    v1beta1: import("../cosmos/nft/v1beta1/query.rpc.query").QueryClientImpl;
                };
                params: {
                    v1beta1: import("../cosmos/params/v1beta1/query.rpc.query").QueryClientImpl;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/query.rpc.query").QueryClientImpl;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/query.rpc.query").QueryClientImpl;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/query.rpc.query").QueryClientImpl;
                };
            };
            nova: {
                gal: {
                    v1: _272.QueryClientImpl;
                };
                ibcstaking: {
                    v1: _273.QueryClientImpl;
                };
                mint: {
                    v1: _274.QueryClientImpl;
                };
                oracle: {
                    v1: _275.QueryClientImpl;
                };
            };
        }>;
        createLCDClient: ({ restEndpoint }: {
            restEndpoint: any;
        }) => Promise<{
            cosmos: {
                auth: {
                    v1beta1: import("../cosmos/auth/v1beta1/query.lcd").LCDQueryClient;
                };
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/query.lcd").LCDQueryClient;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/query.lcd").LCDQueryClient;
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/query.lcd").LCDQueryClient;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/query.lcd").LCDQueryClient;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/query.lcd").LCDQueryClient;
                };
                gov: {
                    v1: import("../cosmos/gov/v1/query.lcd").LCDQueryClient;
                    v1beta1: import("../cosmos/gov/v1beta1/query.lcd").LCDQueryClient;
                };
                group: {
                    v1: import("../cosmos/group/v1/query.lcd").LCDQueryClient;
                };
                mint: {
                    v1beta1: import("../cosmos/mint/v1beta1/query.lcd").LCDQueryClient;
                };
                nft: {
                    v1beta1: import("../cosmos/nft/v1beta1/query.lcd").LCDQueryClient;
                };
                params: {
                    v1beta1: import("../cosmos/params/v1beta1/query.lcd").LCDQueryClient;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/query.lcd").LCDQueryClient;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/query.lcd").LCDQueryClient;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/query.lcd").LCDQueryClient;
                };
            };
            nova: {
                gal: {
                    v1: _268.LCDQueryClient;
                };
                ibcstaking: {
                    v1: _269.LCDQueryClient;
                };
                mint: {
                    v1: _270.LCDQueryClient;
                };
                oracle: {
                    v1: _271.LCDQueryClient;
                };
            };
        }>;
    };
}
